//! pair_gui_with_afc.rs — “everything from pair_gui and afc” in a **single** self‑contained Rust
//! source file that shows how to pair to an iOS device and open an AFC (Apple File Conduit)
//! session in a *native* GUI using **eframe/egui**.
//!
//! This version incorporates the compile‑time fixes you just reported:
//! * **Removed** the stale `house_arrest` import.
//! * Updated to **eframe 0.27**’s `run_native` signature (closure now returns
//!   `Result<Box<dyn App>, Box<dyn std::error::Error + Send + Sync>>`).
//! * Uses the current `UsbmuxdDevice` fields (`udid`, `device_id`,
//!   `connection_type`) instead of the no‑longer‑present `device_name` or
//!   `properties` fields.
//! * Avoids the `plist::Value` super‑fluous conversion that triggered the
//!   `From<&plist::Value>` error you saw.
//!
//! ────────────────────────────────────────────────────────────────────────────────
//! ## Crate features you must enable in *Cargo.toml*
//! ```toml
//! idevice = { version = "^0.1", default-features = false, features = [
//!     "usbmuxd",  # list devices & open lockdown
//!     "pair",      # high‑level pairing helper
//!     "afc"        # Apple File Conduit FS
//! ] }
//! eframe  = { version = "^0.27", features = ["wayland", "x11"] }
//! anyhow  = "^1.0"
//! thiserror = "^1.0"
//! log     = "^0.4"
//! env_logger = "^0.11"
//! tokio   = { version = "^1.43", features = ["rt-multi-thread", "macros"] }
//! ```
//! > **Note:** All asynchronous device traffic runs on a Tokio multi‑threaded
//! > runtime that lives inside the GUI struct so the interface never blocks.
//!
//! ────────────────────────────────────────────────────────────────────────────────
//! ## The code

use anyhow::{Context, Result};
use eframe::{egui, App};
use idevice::{
    afc::AfcClient,
    lockdown::{LockdowndClient, PairRecord},
    usbmuxd::{UsbmuxdConnection, UsbmuxdDevice},
};
use log::{error, info};
use std::sync::Arc;
use thiserror::Error;
use tokio::{runtime::Runtime, sync::mpsc};

//───────────────────────────────────────────────────────────────────────────────
// Error type — displayed verbatim in a red label up top.
//───────────────────────────────────────────────────────────────────────────────
#[derive(Error, Debug)]
pub enum AppError {
    #[error("Device not selected")]
    NoDevice,
    #[error("Device disconnected")]
    Disconnected,
    #[error("{0}")]
    Other(#[from] anyhow::Error),
}

impl From<AppError> for String {
    fn from(err: AppError) -> Self {
        err.to_string()
    }
}

//───────────────────────────────────────────────────────────────────────────────
//  Message bridges between GUI <‑> background task
//───────────────────────────────────────────────────────────────────────────────
#[derive(Debug)]
enum GuiToBg {
    RefreshDevices,
    Pair(String /* udid */),
    ListAfc(String /* udid */, String /* path */),
}

#[derive(Debug)]
enum BgToUi {
    DeviceList(Vec<UsbmuxdDevice>),
    PairComplete { udid: String, pair_record: PairRecord },
    AfcListing { path: String, entries: Vec<FileEntry> },
    Error(String),
}

#[derive(Debug, Clone)]
struct FileEntry {
    name: String,
    is_dir: bool,
    size: Option<u64>,
}

//───────────────────────────────────────────────────────────────────────────────
//  The actual egui application
//───────────────────────────────────────────────────────────────────────────────
struct PairGuiApp {
    rt: Arc<Runtime>,
    tx: mpsc::UnboundedSender<GuiToBg>,
    rx: mpsc::UnboundedReceiver<BgToUi>,

    // UI‑state ---------------------------------------------------------------
    devices: Vec<UsbmuxdDevice>,
    selected: Option<String>, // UDID
    paired: bool,
    cwd: String,
    entries: Vec<FileEntry>,
    last_error: Option<String>,
}

impl PairGuiApp {
    fn spawn_worker(rt: &Arc<Runtime>, mut rx: mpsc::UnboundedReceiver<GuiToBg>, tx: mpsc::UnboundedSender<BgToUi>) {
        let tx_clone = tx.clone();
        rt.spawn(async move {
            let mut mux = match UsbmuxdConnection::new().await {
                Ok(c) => c,
                Err(e) => {
                    let _ = tx_clone.send(BgToUi::Error(format!("usbmuxd: {e}")));
                    return;
                }
            };

            use std::collections::HashMap;
            let mut pair_cache: HashMap<String, PairRecord> = HashMap::new();

            while let Some(cmd) = rx.recv().await {
                match cmd {
                    GuiToBg::RefreshDevices => match mux.list_devices().await {
                        Ok(list) => {
                            let _ = tx_clone.send(BgToUi::DeviceList(list));
                        }
                        Err(e) => {
                            let _ = tx_clone.send(BgToUi::Error(e.to_string()));
                        }
                    },

                    GuiToBg::Pair(udid) => {
                        if let Some(rec) = pair_cache.get(&udid) {
                            let _ = tx_clone.send(BgToUi::PairComplete { udid, pair_record: rec.clone() });
                            continue;
                        }
                        match LockdowndClient::pair_with_udid(&udid).await {
                            Ok(rec) => {
                                pair_cache.insert(udid.clone(), rec.clone());
                                let _ = tx_clone.send(BgToUi::PairComplete { udid, pair_record: rec });
                            }
                            Err(e) => {
                                let _ = tx_clone.send(BgToUi::Error(format!("pairing: {e}")));
                            }
                        }
                    }

                    GuiToBg::ListAfc(udid, path) => match AfcClient::connect(&udid).await {
                        Ok(mut afc) => match afc.list_dir(&path).await {
                            Ok(list) => {
                                let items = list
                                    .into_iter()
                                    .map(|e| FileEntry { name: e.name, is_dir: e.is_directory, size: e.size })
                                    .collect();
                                let _ = tx_clone.send(BgToUi::AfcListing { path, entries: items });
                            }
                            Err(e) => {
                                let _ = tx_clone.send(BgToUi::Error(format!("afc ls: {e}")));
                            }
                        },
                        Err(e) => {
                            let _ = tx_clone.send(BgToUi::Error(format!("open afc: {e}")));
                        }
                    },
                }
            }
        });
    }

    fn bg(&self, msg: GuiToBg) {
        let _ = self.tx.send(msg);
    }
}

impl App for PairGuiApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Pump background messages first.
        while let Ok(msg) = self.rx.try_recv() {
            match msg {
                BgToUi::DeviceList(list) => {
                    self.devices = list;
                }
                BgToUi::PairComplete { udid, .. } => {
                    if Some(&udid) == self.selected.as_ref() {
                        self.paired = true;
                        info!("paired with {udid}");
                    }
                }
                BgToUi::AfcListing { path, entries } => {
                    self.cwd = path;
                    self.entries = entries;
                }
                BgToUi::Error(e) => {
                    self.last_error = Some(e);
                }
            }
        }

        // ── UI ────────────────────────────────────────────────────────────
        egui::TopBottomPanel::top("top").show(ctx, |ui| {
            if ui.button("🔄 Refresh").clicked() {
                self.bg(GuiToBg::RefreshDevices);
            }
            if let Some(err) = &self.last_error {
                ui.colored_label(egui::Color32::RED, err);
            }
        });

        egui::SidePanel::left("devices").show(ctx, |ui| {
            ui.heading("Devices");
            ui.separator();
            for dev in &self.devices {
                let label = format!("id={} udid={}", dev.device_id, dev.udid);
                if ui.selectable_label(Some(&dev.udid) == self.selected.as_ref(), label).clicked() {
                    self.selected = Some(dev.udid.clone());
                    self.paired = false;
                }
            }
            ui.separator();
            if ui.button("Pair / Trust").clicked() {
                if let Some(id) = &self.selected {
                    self.bg(GuiToBg::Pair(id.clone()));
                }
            }
        });

        egui::CentralPanel::default().show(ctx, |ui| {
            ui.heading(format!("AFC — {}", self.cwd));
            ui.separator();
            if !self.paired {
                ui.label("Select a device and click *Pair / Trust*.");
                return;
            }
            egui::ScrollArea::vertical().show(ui, |ui| {
                for f in &self.entries {
                    let icon = if f.is_dir { "📁" } else { "📄" };
                    let label = format!("{icon} {}", f.name);
                    if ui.selectable_label(false, label).clicked() && f.is_dir {
                        let next = if self.cwd == "/" { format!("/{}", f.name) } else { format!("{}/{}", self.cwd, f.name) };
                        self.bg(GuiToBg::ListAfc(self.selected.clone().unwrap(), next));
                    }
                }
            });
        });

        ctx.request_repaint_after(std::time::Duration::from_millis(100));
    }
}

//───────────────────────────────────────────────────────────────────────────────
//  Main — sets up logging, Tokio, channels, and the GUI.
//───────────────────────────────────────────────────────────────────────────────
fn main() -> Result<()> {
    if std::env::var("RUST_LOG").is_err() {
        std::env::set_var("RUST_LOG", "info");
    }
    env_logger::init();

    let rt = Arc::new(Runtime::new().context("tokio")?);

    let (tx_gui, rx_worker) = mpsc::unbounded_channel::<GuiToBg>();
    let (tx_worker, rx_gui) = mpsc::unbounded_channel::<BgToUi>();

    PairGuiApp::spawn_worker(&rt, rx_worker, tx_worker);

    let app = PairGuiApp {
        rt,
        tx: tx_gui,
        rx: rx_gui,
        devices: Vec::new(),
        selected: None,
        paired: false,
        cwd: "/".into(),
        entries: Vec::new(),
        last_error: None,
    };

    let native = eframe::NativeOptions::default();
    eframe::run_native(
        "Pair GUI (AFC)",
        native,
        Box::new(move |_cc| Ok::<_, Box<dyn std::error::Error + Send + Sync>>(Box::new(app))),
    )?;
    Ok(())
}

//───────────────────────────────────────────────────────────────────────────────
// End of file
//───────────────────────────────────────────────────────────────────────────────
